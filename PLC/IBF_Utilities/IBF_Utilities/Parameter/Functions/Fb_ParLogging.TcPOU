<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="Fb_ParLogging" Id="{70cb49c5-c474-4a5d-8c59-0231168edf6a}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK PUBLIC Fb_ParLogging EXTENDS FB_ParameterHandler
VAR_OUTPUT
	bReadBusy		: BOOL		:= FALSE	; // File acces Bussy
	bWriteBusy		: BOOL 		:= FALSE	; // file write bussy
	bError			: BOOL		:= FALSE	; // File acces error
	nErrId			: UDINT		:= 0		; // File acces error Id
	nRow	 		: UDINT 	:= 0		;(* Row number (record) *)
	nColumn			: UDINT 	:= 0		;(* Column number (record field) *)
	nInitStep		: UDINT 	:= 0 		; // Initialization step
END_VAR
VAR
	// ====== Compare array =====
		arFileParameters		: ARRAY [1..GVL_Parameters.MAX_PARAMETERS] OF Udt_Parameter;
		nNumberOfParFromFile	: UDINT; // Number of parameters read from file
		nNumberOfChanges		: UDINT; // Number of parameter changes 
		arChangeLog				: ARRAY [0..(GVL_Parameters.MAX_PARAMETERS * 2)] OF STRING ; // Parameter change log 
	// ====== Internal commands ======
		bCmdParFileWrite	: BOOL ; // write alle parameters to .csv file
		bCmdParLogWrite		: BOOL ; // write all changes to .csv file
		bCmdParFileRead		: BOOL ; // Read all parameters from .csv file 
	// ====== File headers ======
		sCsvFileHeader : STRING := 'NUMBER;NAME;TYPE;DISCRIPTION;FACTORY;MAXIMUM;MINIMUM;UNIT;VALUE$L';
	// ====== internal status ======
		bInitOK				: BOOL 	:= FALSE ; // init has been done succesfully
		bFileNotFound		: BOOL 	:= FALSE ; // Parameter file has not been found 
		bParCountDiference	: BOOL 	:= FALSE ; // The number of parameters from file does not match machine 
		bParNumberDiference	: BOOL 	:= FALSE ; // The parameters from file do not match machine
		nDiferenceRow		: UDINT	:= 0	 ; // The file array row number in which diferences were found
 
	// ====== Current step =====
		nReadStep			: INT 	:= 0 	; // File read stepper
		nLogStep			: INT 	:= 0 	; // File logging step
		nWriteStep			: INT 	:= 0 	; // File Write stepper

	// ====== Read variables ======
		hFile				: UINT	:= 0;(* File handle of the source file *)
		cbField				: UDINT	;(* Number of bytes in field buffer *)

	// ====== Read variables ======
		sCSVLine			: T_MaxString := '';(* Single CSV text line (row, record), we are using string as record buffer (your are able to see created fields) *)
		sCSVField			: T_MaxString := '';(* Single CSV field value (column, record field) *)
		sCSVFieldString		: T_MaxString := '';// CSV field converted into string
	// ====== Functions ======
		fbFileOpenForRead	: FB_FileOpen	;(* Opens file *)
		fbFileOpenForWrite	: FB_FileOpen	;(* Opens file *)
		fbFileOpenForLog	: FB_FileOpen	;(* Opens file *)
		fbFileClose			: FB_FileClose	;(* Closes file *)
		fbFileGets			: FB_FileGets	;(* Reads one record (line) *)
		fbFilePuts			: FB_FilePuts	;(* Writes one record (line) *)
		fbReader			: FB_CSVMemBufferReader;(* Helper function block used to parse CSV data bytes (single record line) *)
		fbWriter			: FB_CSVMemBufferWriter;(* Helper function block used to create CSV data bytes (single record line) *)
	
	// Par Read timeout 
		TonParWriteTimeout	: TON := (PT := T#5S) ; // Timeout for parameter read
		TonParreadTimeout	: TON := (PT := T#5S) ; // Timeout for parameter read
		
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[SUPER^();

// ===== init =====
	IF NOT binitok THEN 
		RETURN;
	ELSE 
		CmdParWriteToFile();
		CmdParLoadFromFile();
	END_IF
	]]></ST>
    </Implementation>
    <Folder Name="Private" Id="{4ef361fb-7879-4d00-8723-9a400aa8a5ef}" />
    <Method Name="CmdParLoadFromFile" Id="{5fca42a6-0210-4da3-921b-30c71fd4a2e1}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE CmdParLoadFromFile : BOOL
VAR_INPUT
END_VAR
VAR 
	i : UDINT ;
	fTempValue	: LREAL ; // Tomporary value to be placed in save value
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ExecFileRead() THEN 
	;
ELSE
	RETURN;
END_IF

// Compare Parameter counters 
IF nNumberOfParameters <> nNumberOfParFromFile THEN
	bParCountDiference := TRUE ;
ELSE 
	bParCountDiference := FALSE ;
END_IF

// Compare Parameter from file with parameters in machine then write from file to machine
bParNumberDiference := FALSE ;
nDiferenceRow		:= 0 ;
IF NOT bParCountDiference THEN 
	FOR i := 1 TO nNumberOfParameters DO
		IF arParameters[i].nNumber <> arFileParameters[i].nNumber THEN
			bParNumberDiference := TRUE ;
			nDiferenceRow		:= i ;
			CONTINUE;
		ELSE
			IF (arParameters[i].pParameter^.fValue <> arFileParameters[i].fValue) THEN 
				fTempValue := arParameters[i].pParameter^.fValue;  
			ELSE
				fTempValue := 0;
			END_IF
			arParameters[i].pParameter^			:= arFileParameters[i];
			arParameters[i].pParameter^.fSaved 	:= fTempValue;
		END_IF
	END_FOR
END_IF 

CmdParLoadFromFile := TRUE ;]]></ST>
      </Implementation>
    </Method>
    <Method Name="CmdParWriteToFile" Id="{aa854d64-1120-4bd0-ad5a-36d498335059}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE CmdParWriteToFile : BOOL
VAR_INPUT
END_VAR
VAR
	i : UDINT ;
	sDTString : STRING ;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF bCmdParFileWrite THEN 
	FOR i := 1 TO nNumberOfParameters DO
			// Save current actual value for later restore
			IF arParameters[i].pParameter^.fValue <> arFileParameters[i].fValue THEN
				arParameters[i].pParameter^.fSaved := arFileParameters[i].fValue ;
			END_IF
			arFileParameters[i] := arParameters[i].pParameter^ ;
	END_FOR
END_IF

//IF nNumberOfChanges > 0 AND NOT bParCountDiference THEN 
//	ExecWriteToLog();
//END_IF
CmdParWriteToFile := ExecFileWrite();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="CmdSavePar" Id="{bbcba8cc-bd94-4323-bfac-4059573c8d29}">
      <Declaration><![CDATA[METHOD PUBLIC CmdSavePar : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[bCmdParFileWrite := TRUE ;

CmdSavePar := bWriteBusy ;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExecFileRead" Id="{667e0f14-aa11-404d-9b7f-8790b7d6f1b6}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE ExecFileRead : BOOL
VAR_INPUT
END_VAR
VAR
	i : UDINT := 0 ;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ===== Wait for command =====
	IF bCmdParFileRead OR bReadBusy THEN 
		;
	ELSE
		RETURN ;
	END_IF

// ===== prepare for file read =====
	CASE nReadStep OF
		0:	(* Wait for rising edge at bRead variable *)
			bReadBusy		:= TRUE;
			bFileNotFound	:= FALSE ;
			bCmdParFileRead := FALSE ;
			bError			:= FALSE;
			nErrId			:= 0;
			hFile			:= 0;
			nRow			:= 0;
			nColumn			:= 0;
			nReadStep 			:= 1;
	
		1:	(* Open source file *)
			fbFileOpenForRead(  bExecute := FALSE  );
			fbFileOpenForRead( sNetId := GVL_Parameters.sNetId, sPathName := GVL_Parameters.sPARLIST_FILE, nMode := FOPEN_MODEREAD OR FOPEN_MODETEXT,(* Open file in text mode! *)
						ePath := PATH_GENERIC, bExecute := TRUE );
			nReadStep := 2;
	
		2:(* Wait until open not busy *)
			fbFileOpenForRead( bExecute := FALSE, bError => bError, nErrID => nErrID, hFile => hFile );
			IF NOT fbFileOpenForRead.bBusy THEN
				IF NOT fbFileOpenForRead.bError THEN
					nReadStep := 3;
				ELSE(* Error: file not found? *)
					bFileNotFound := TRUE ;
					nReadStep := 100;
				END_IF
			END_IF
		3:	(* Read single line (record) *)
			fbFileGets( bExecute := FALSE );
			fbFileGets( sNetId := GVL_Parameters.sNetId, hFile := hFile, bExecute := TRUE );
			nReadStep := 4;
		4:(* Wait until read not busy *)
			fbFileGets( bExecute := FALSE, bError => bError, nErrID => nErrID, sLine => sCSVLine );
			IF NOT fbFileGets.bBusy THEN
				IF NOT fbFileGets.bError THEN
					IF fbFileGets.bEOF THEN
						nReadStep 				:= 10;(* End of file reached => Close source file *)
					ELSE
						(* FB_FileGets returns text line without the CR (carriage return) character.
						We have to restore the CR character (replace the $L character with $R$L characters) *)
						IF RIGHT( sCSVLine, 1 ) = '$L' THEN
							sCSVLine := REPLACE( sCSVLine, '$R$L', 2, LEN( sCSVLine ) );
						END_IF
						nReadStep := 5;
					END_IF
				ELSE(* Error *)
					nReadStep := 100;
				END_IF
			END_IF
		5:(* Parse single line (record) *)
			fbReader.eCmd := eEnumCmd_First;(* Read first field value *)
			REPEAT
				fbReader( pBuffer := ADR( sCSVLine ), cbBuffer := SIZEOF( sCSVLine ), getValue => sCSVField );
				IF fbReader.bOk THEN
					fbReader.eCmd := eEnumCmd_Next;(* Read next field value *)
					IF ( nRow <= GVL_Parameters.MAX_PARAMETERS ) AND nRow > 0 THEN
						IF ( nColumn <= GVL_Parameters.PAR_COLUMNS ) THEN
							sCSVFieldString	:= CSVFIELD_TO_STRING( sCSVField, TRUE);
							CASE nColumn OF
									0: // Parameter number [Udint]	
										arFileParameters[nRow].nNumber		:= STRING_TO_UDINT(sCSVFieldString); 						
									1: // Parameter Name [string]
										arFileParameters[nRow].sName 		:= sCSVFieldString;							
									2: // Parameter type [String]
										arFileParameters[nRow].sType 		:= sCSVFieldString;	
									3: // Parameter discription [string]
										arFileParameters[nRow].sDiscription	:= sCSVFieldString;						
									4: // Parameter factory value [LREAL]
										arFileParameters[nRow].fFactory		:= STRING_TO_LREAL(sCSVFieldString);							
									5: // Parameter maximum value [LREAL]
										arFileParameters[nRow].fMaximum		:= STRING_TO_LREAL(sCSVFieldString);							
									6: // Parameter minimum value[LREAL]
										arFileParameters[nRow].fMinimum		:= STRING_TO_LREAL(sCSVFieldString);							
									7: // Parameter unit {String]
										arFileParameters[nRow].sUnit 		:= sCSVFieldString;							
									8: // Parameter value [LREAL]
										arFileParameters[nRow].fValue		:= STRING_TO_LREAL(sCSVFieldString);							
							ELSE
								;
							END_CASE
							nColumn := nColumn + 1;(* Increment number of read columns *)
						END_IF
					END_IF
					IF fbReader.bCRLF THEN(* CRLF == TRUE => End of reacord reached *)
						nNumberOfParFromFile := nRow;
						nRow 		:= nRow + 1;(* Increment number of read records *)
						nColumn 	:= 0;(* Reset number of columns *)
					END_IF
				ELSE(* Error: End of record reached or all fields read *)
					nReadStep := 3;(* Try to read next line *)
				END_IF
			UNTIL NOT fbReader.bOk
			END_REPEAT
		10:	(* Close source file *)
			fbFileClose( bExecute := FALSE );
			fbFileClose( sNetId := GVL_Parameters.sNetId, hFile := hFile, bExecute := TRUE );
			nReadStep := 11;
	
		11:(* Wait until close not busy *)
			fbFileClose( bExecute := FALSE, bError => bError, nErrID => nErrID );
			IF ( NOT fbFileClose.bBusy ) THEN
				hFile := 0;
				nReadStep := 100;
			END_IF
		100: (* Error or ready nReadStep => cleanup *)
			IF ( hFile <> 0 ) THEN
				nReadStep := 10; (* Close the source file *)
			ELSE
				bReadBusy := FALSE;
				ExecFileRead := TRUE ;
				nReadStep := 0;	(* Ready *)
			END_IF
	END_CASE
	
	TonParreadTimeout(IN := bReadBusy);
	bError S= TonParreadTimeout.Q;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExecFileWrite" Id="{4f304946-cc76-469f-a7d8-a3de4893dd6a}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD INTERNAL ExecFileWrite : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ===== Wait for command =====
	IF bCmdParFileWrite OR bWriteBusy THEN 
		;
	ELSE
		RETURN ;
	END_IF

// ===== Start file write =====
	CASE nWriteStep OF
		0:	(* Wait for rising edge at bWrite variable *)
				bFileNotFound		:= FALSE ;
				bParCountDiference	:= FALSE ;
				bWriteBusy 			:= TRUE;
				bCmdParFileWrite	:= FALSE ;
				bError				:= FALSE;
				nErrId				:= 0;
				hFile				:= 0;
				nRow				:= 0;
				nWriteStep 				:= 1;
		1:	(* Open source file *)
			fbFileOpenForWrite(  bExecute := FALSE  );
			fbFileOpenForWrite( sNetId := GVL_Parameters.sNetId, sPathName := GVL_Parameters.sPARLIST_FILE, nMode := FOPEN_MODEWRITE OR FOPEN_MODETEXT,(* Open file in TEXT mode! *)
						ePath := PATH_GENERIC, bExecute := TRUE );
			nWriteStep := 2;
		2:(* Wait until open not busy *)
			fbFileOpenForWrite( bExecute := FALSE, bError => bError, nErrID => nErrID, hFile => hFile );
			IF NOT fbFileOpenForWrite.bBusy THEN
				IF NOT fbFileOpenForWrite.bError THEN
					nWriteStep := 3;
				ELSE(* Error: file not found? *)
					nWriteStep := 100;
				END_IF
			END_IF
	
		3:(* Convert one PLC parameter field to CSV format *)
			// Go column by column to avoid return strings that are too long
			// TODO test (default string constructor is 80 characters, but can be extended to <?>)
			IF nRow = 0 THEN 
				sCSVLine := sCsvFileHeader;
			ELSE
				sCSVLine := F_ParToCsvLine(stParameter := arFileParameters[nRow], nColumn := nColumn);
			END_IF
			nWriteStep := 4 ;
		4:	(* Write single Field *)
			fbFilePuts( bExecute := FALSE );
			fbFilePuts( sNetId := GVL_Parameters.sNetId, hFile := hFile, sLine := sCSVLine, bExecute := TRUE );
			nWriteStep := 5;
		5:(* Wait until write not busy *)
			fbFilePuts( bExecute := FALSE, bError => bError, nErrID => nErrID );
			IF NOT fbFilePuts.bBusy THEN
				IF NOT fbFilePuts.bError THEN
					nWriteStep := 3;(* Write next record *)
					IF nRow = 0 OR nColumn = 8 THEN
						nColumn := 0 ;
						nRow := nRow + 1;
						IF nRow = nNumberOfParameters + 1 THEN
							nWriteStep := 10;
						END_IF;
					ELSE
						nColumn := nColumn + 1;
					END_IF
				ELSE(* Error *)
					nWriteStep := 100;
				END_IF
			END_IF
		10:	(* Close source file *)
			fbFileClose( bExecute := FALSE );
			fbFileClose( sNetId := GVL_Parameters.sNetId, hFile := hFile, bExecute := TRUE );
			nWriteStep := 11;
	
		11:(* Wait until close not busy *)
			fbFileClose( bExecute := FALSE, bError => bError, nErrID => nErrID );
			IF ( NOT fbFileClose.bBusy ) THEN
				hFile := 0;
				nWriteStep := 100;
			END_IF
	
		100: (* Error or ready nWriteStep => cleanup *)
			IF ( hFile <> 0 ) THEN
				nWriteStep := 10; (* Close the source file *)
			ELSE
				bParCountDiference 	:= FALSE ;
				bWriteBusy 			:= FALSE;
				ExecFileWrite		:= TRUE ;
				nWriteStep 			:= 0;	(* Ready *)
			END_IF
	
	END_CASE
	
	TonParWriteTimeout(IN := bWriteBusy);
	bError	S= TonParWriteTimeout.Q ;
	

ExecFileWrite := TRUE ;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExecWriteToLog" Id="{236b4ab3-7a1a-442f-8443-9a38dfaf49dc}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE ExecWriteToLog : BOOL
VAR_INPUT
END_VAR
VAR
	sTempField : STRING ;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ===== Wait for command =====
	IF bWriteBusy OR bCmdParLogWrite THEN 
		;
	ELSE
		RETURN ;
	END_IF

// ===== Start file write =====
CASE nLogStep OF
	0:	(* Wait for rising edge at bWrite variable *)
			bWriteBusy 			:= TRUE;
			bCmdParLogWrite	:= FALSE ;
			bError				:= FALSE;
			nErrId				:= 0;
			hFile				:= 0;
			nRow				:= nNumberOfChanges * 2; // Twice the number of changes because old and new values are stored sequentially in teh same array
			nLogStep 			:= 1;
	1:	(* Open source file *)
		fbFileOpenForLog(  bExecute := FALSE  );
		fbFileOpenForLog( sNetId := GVL_Parameters.sNetId, sPathName := GVL_Parameters.sPARLIST_FILE, nMode := FOPEN_MODETEXT,(* Open file in TEXT mode! *)
					ePath := PATH_GENERIC, bExecute := TRUE );
		nLogStep := 2;
	2:(* Wait until open not busy *)
		fbFileOpenForLog( bExecute := FALSE, bError => bError, nErrID => nErrID, hFile => hFile );
		IF NOT fbFileOpenForLog.bBusy THEN
			IF NOT fbFileOpenForLog.bError THEN
				nLogStep := 3;
			ELSE(* Error: file not found? *)
				nLogStep := 100;
			END_IF
		END_IF

	3:(* Convert one PLC record to CSV format *)
		sCSVLine := arChangeLog[nRow];
		nLogStep := 4 ;
	4:	(* Write single text line *)
		fbFilePuts( bExecute := FALSE );
		fbFilePuts( sNetId := GVL_Parameters.sNetId, hFile := hFile, sLine := sCSVLine, bExecute := TRUE );
		nLogStep := 5;

	5:(* Wait until write not busy *)
		fbFilePuts( bExecute := FALSE, bError => bError, nErrID => nErrID );
		IF NOT fbFilePuts.bBusy THEN
			IF nRow = 0 THEN
				nNumberOfChanges := 0;
				nLogStep := 10;
			ELSIF NOT fbFilePuts.bError THEN
				arChangeLog[nRow] := ''; // Delete change from log
				nRow := nRow - 1;
				nLogStep := 3;(* Write next record *)
			ELSE(* Error *)
				nLogStep := 100;
			END_IF
		END_IF
	10:	(* Close source file *)
		fbFileClose( bExecute := FALSE );
		fbFileClose( sNetId := GVL_Parameters.sNetId, hFile := hFile, bExecute := TRUE );
		nLogStep := 11;

	11:(* Wait until close not busy *)
		fbFileClose( bExecute := FALSE, bError => bError, nErrID => nErrID );
		IF ( NOT fbFileClose.bBusy ) THEN
			hFile := 0;
			nLogStep := 100;
		END_IF

	100: (* Error or ready nLogStep => cleanup *)
		IF ( hFile <> 0 ) THEN
			nLogStep := 10; (* Close the source file *)
		ELSE
			bWriteBusy := FALSE;
			nLogStep := 0;	(* Ready *)
		END_IF
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Init" Id="{e3729afd-d9ab-4f85-a26c-897c677d5301}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PUBLIC Init : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Read parameters from .CSV file and check if load is valid

CASE nInitStep OF 
	0: //check if init has been done 
		bInitOK 	:= FALSE;
		nInitStep 	:= 10 ;
	10: // start File read
		bCmdParFileRead := TRUE ;
		nInitStep := 11; 
	11: // Execute file read 
		IF CmdParLoadFromFile() THEN 
			nInitStep := 12 ;
		END_IF
	12: // Check if read is valid 
		IF bFileNotFound OR bParCountDiference THEN 
			nInitStep := 20 ;
		ELSE 
			nInitStep := 100 ;
		END_IF
	20: // start File write
		bCmdParFileWrite:= TRUE ;
		nInitStep		:= 21 ;
	21: // Wait for file write to finish
		IF CmdParWriteToFile() THEN 
			nInitStep := 100 ;
		ELSIF bError THEN 
			nInitStep := 900 ; 
		END_IF 
	100: // Init ok 
		bInitOK 	:= TRUE ;
		Init		:= TRUE ;
		nInitStep	:= 0 ;
	900: // file fault	
		bInitOK := FALSE ;
		RETURN ;
	ELSE 
		;
END_CASE
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>