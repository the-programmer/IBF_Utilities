<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_FaultHandler" Id="{08f65884-c647-4a29-b7ba-51d088979c07}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_FaultHandler
(* 
The faulthandler is responsible for 
	- providing the means for objects to register their faults
	- reporting the active fault types (i.e., message, fatal fault, etc.) --> arActiveFaultTypes
	- providing the means to reset a fault type
	- keeping a log of all faults

It is not responsible for
	- resetting the actual fault (this is up to the object that registered the fault)
	- handling any HMI related functionality

Active faults do not disappear from the log, the need to be manually cleared by issuing a CmdReset.
*)
VAR CONSTANT
	MAX_FAULTS_IN_LOG : UINT := 10;
END_VAR
VAR_OUTPUT
	arFaultLog 			: ARRAY [1..MAX_FAULTS_IN_LOG] OF UDT_FaultLogItem;
	nFaultsInLog 		: UINT;
	nActiveFaults 		: UINT;
	arActiveFaultTypes 	: ARRAY[0..(E_FaultTypes._ENUM_SIZE - 1)] OF BOOL; // Status of each fault type
END_VAR
VAR
	bCmdReset : BOOL;
	eResetState : E_ResetState;
	arActiveFaultTypes_Internal : ARRAY[0..(E_FaultTypes._ENUM_SIZE - 1)] OF BOOL; // The actual status of each fault type, which is reported unless the reset cycle is active
	
	nLogIndex : UINT; // Array index of the last added item in the log (zero until the first item arrives)
	nIterIndex : UINT; // Index of the fault log iterator (used for properties First and Next)
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[ExecReset();

GetNumberOfActiveFaults();
]]></ST>
    </Implementation>
    <Folder Name="Private" Id="{2e728eb6-79bc-4de8-8875-9d08a8df9edd}" />
    <Method Name="CmdAddFault" Id="{cd103280-aca4-4b4a-a070-10b84eec5ffb}">
      <Declaration><![CDATA[METHOD PUBLIC CmdAddFault : BOOL
(*
CmdAddFault should be called every cycle.
If the fault is active, it's corresponding fault type is enabled.
Updates the fault log.
*)
VAR_IN_OUT
	stFault : UDT_Fault; // active fault structure input
END_VAR
VAR_INPUT
	stIdentity : UDT_Identity;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Report active fault type
arActiveFaultTypes_Internal[stFault.FaultType] S= stFault.Active;

// Update the log
UpdateLog(stFault, stIdentity);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="CmdReset" Id="{a9c5d6bc-61dd-41fc-99d9-5b14d5fa2712}">
      <Declaration><![CDATA[METHOD PUBLIC CmdReset : BOOL // Reset faults; caller is responsible for stopping the call once TRUE is returned
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Trigger the reset cycle
IF (eResetState = E_ResetState.Idle) THEN
	bCmdReset := TRUE;
END_IF

CmdReset := (eResetState = E_ResetState.WaitForFaults); // Let the caller know when the reset cycle is finished
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExecReset" Id="{5409ab96-3bb3-0061-05e8-ad57d1261a31}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE ExecReset : BOOL
VAR
	i : UINT; // Iterator
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE eResetState OF
	E_ResetState.Idle: // Wait for reset command
		IF bCmdReset THEN
			// Start the reset cycle
			bCmdReset := FALSE;
			eResetState := E_ResetState.ResetFaultTypes;
		ELSE
			// Report the status of each fault type	
			FOR i:= 0 TO (E_FaultTypes._ENUM_SIZE - 1) DO		
				arActiveFaultTypes[i] := arActiveFaultTypes_Internal[i];
			END_FOR
		END_IF
	E_ResetState.ResetFaultTypes: 
		// During a reset, the reported fault types are not changed
		// This avoids that faults are not reported for 1 PLC cycle, even though they are still active
		// We do however clear the internal fault types, which are updated automatically by the CmdAddFaults calls
		// from the system components.
		FOR i:= 0 TO (E_FaultTypes._ENUM_SIZE - 1) DO		
			arActiveFaultTypes_Internal[i] := FALSE;
		END_FOR
		// Clear active state of all fault in the log
		
		eResetState := E_ResetState.WaitForFaults;
	E_ResetState.WaitForFaults: // Allow the PLC one cycle to re-add faults
		eResetState := E_ResetState.Idle;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetNumberOfActiveFaults" Id="{56b85226-7a15-0380-3007-0d96d035d37f}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE GetNumberOfActiveFaults : UINT
VAR
	i : UINT; // Iterator
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Get the number of active faults
nActiveFaults := 0;
FOR i := 1 TO MAX_FAULTS_IN_LOG DO
	IF (arFaultLog[i].stFault.Active) THEN 
		nActiveFaults := nActiveFaults + 1;
	END_IF
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Property Name="Head" Id="{51df95bf-2d5c-0e2f-1669-066486ace38d}">
      <Declaration><![CDATA[PROPERTY PUBLIC Head : UDT_FaultLogItem // Returns the head of the log (the latest item added)
]]></Declaration>
      <Get Name="Get" Id="{5da39590-30a9-04b4-307b-1dd3ceac2537}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[nIterIndex := MAX(1, nLogIndex);
Head := arFaultLog[nIterIndex];
]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{f26a9a04-102d-0fab-2b21-bb756981a144}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="Next" Id="{3bc770ea-8ea7-000b-0986-7649ccc14e3e}">
      <Declaration><![CDATA[PROPERTY PUBLIC Next : UDT_FaultLogItem // Get the next item in the log (travelling backwards through the array)]]></Declaration>
      <Get Name="Get" Id="{fcd54202-6b03-0138-1a15-35466f1589c9}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[nIterIndex := nIterIndex - 1;
IF nIterIndex = 0 THEN
	nIterIndex := MAX_FAULTS_IN_LOG;
END_IF
Next := arFaultLog[nIterIndex];
]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{cac173bd-6bf0-0aee-34ab-d083a619fe0b}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="UpdateLog" Id="{9b29b2d1-5975-05b2-2182-eff98e668948}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE UpdateLog : BOOL
(*
Update the fault log array. 
If a fault becomes active, it is added to the array and the start time is updated.
If a fault stops being active, the end time is updated.
Inactive faults are cleared by CmdReset.
*)
VAR_IN_OUT
	stFault : UDT_Fault;
END_VAR
VAR_INPUT
	stIdentity : UDT_Identity;
END_VAR
VAR
	sId : STRING;
	nFaultIndexInLog : UINT;
	i : UINT; // Iterator
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Check if the fault already exists in the log. 
// For this, we need to compare the description and the fault ID.

// First, build the fault ID
sId := TO_STRING(stFault.FaultType);
sId := CONCAT(sId,'.');
IF stIdentity.nParentId > 0 THEN
	sId := CONCAT(sId,UDINT_TO_STRING(stIdentity.nParentId));
	sId := CONCAT(sId,'.');
END_IF
sId := CONCAT(sId,UINT_TO_STRING(stIdentity.nId));
sId := CONCAT(sId,'.');
sId := CONCAT(sId,UDINT_TO_STRING(stIdentity.eComponentType));
sId := CONCAT(sId,'.');
sId := CONCAT(sId,stIdentity.sName);

// Now check if the fault already exists in the log
FOR i := 1 TO MAX_FAULTS_IN_LOG DO
	IF (arFaultLog[i].Id = sId) 
		AND (arFaultLog[i].stFault.Description = stFault.Description)
	THEN // Found fault in the log
		nFaultIndexInLog := i;
		EXIT; // No need to iterate any further
	END_IF
END_FOR

IF nFaultIndexInLog > 0 THEN // Already exists in the log
	IF (NOT stFault.Active) 
		AND (ANY_TO_DWORD(arFaultLog[nLogIndex].EndTime) = 0) // End time was never updated
	THEN // No longer active, update end time and active state
		arFaultLog[nLogIndex].stFault.Active := FALSE;
		arFaultLog[nLogIndex].EndTime := Sys_Variables.SystemTime;
	END_IF
ELSIF stFault.Active THEN // New active fault, add it to the log
	// Update the log index (if full, move to beginning of the log)
	nLogIndex := (nLogIndex MOD MAX_FAULTS_IN_LOG) + 1;
	nFaultsInLog := MIN(nFaultsInLog + 1, MAX_FAULTS_IN_LOG);
	// Copy to log and update start time
	arFaultLog[nLogIndex].stFault := stFault;
	arFaultLog[nLogIndex].Id := sId;
	arFaultLog[nLogIndex].StartTime := Sys_Variables.SystemTime;
END_IF
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>